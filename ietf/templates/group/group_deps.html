{% extends "group/group_base.html" %}
{# Copyright The IETF Trust 2015, All Rights Reserved #}
{% load origin static %}
{% block morecss %}
#deps-modal .modal-body {
height: 100vh;
}
{% endblock %}
{% block group_content %}
{% origin %}
<button id="show-deps" data-href="{% url 'ietf.group.views.dependencies_json' group_type=group.type_id acronym=group.acronym %}"
    type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal"
    data-bs-target="#deps-modal">
    Modal <i class="bi bi-diagram-3"></i>
</button>
<div class="modal fade" id="deps-modal" tabindex="-1" aria-labelledby="deps-modal-label"
    aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deps-modal-label">Document
                    dependencies</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"
                    aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="d-flex justify-content-center">
                    <div class="spinner-border m-5" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <div class="btn-group me-auto" role="group" aria-label="Pan and zoom the diagram">
                    <small class="text-muted">Pan and zoom the dependency
                        graph.</small>
                </div>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}
{% block js %}
<script src="{% static 'ietf/js/d3.js' %}"></script>
<script>
$(document)
    .ready(() => {
        $("#show-deps")
            .trigger("click");
    });

// code adapated from https://observablehq.com/@mbostock/fit-text-to-circle

const line_height = 16; // FIXME: get from bs5
const font = `${line_height - 2}px sans-serif`;

const link_color = {
    refinfo: "green",
    refnorm: "pink",
    replaces: "blue",
    refunk: "pink",
    downref: "red"
};

const node_color = {
    replaced: "orange",
    dead: "grey",
    expired: "lightgrey"
};

const node_stroke = {
    individual: 1,
    group: 4
};

function lines(text) {
    let line;
    let line_width_0 = Infinity;
    const lines = [];
    var words = text.trim()
        .split(/-/g)
        .map((x, i, a) => i < a.length - 1 ? x + "-" : x);
    if (words.length == 1) {
        words = text.trim()
            .split(/rfc/g)
            .map((x, i, a) => i < a.length - 1 ? x + "RFC" : x);
    }
    const target_width = Math.sqrt(measure_width(text.trim()) *
        line_height);
    for (let i = 0, n = words.length; i < n; ++i) {
        let line_text = (line ? line.text : "") + words[i];
        let line_width = measure_width(line_text);
        if ((line_width_0 + line_width) / 2 < target_width) {
            line.width = line_width_0 = line_width;
            line.text = line_text;
        } else {
            line_width_0 = measure_width(words[i]);
            line = { width: line_width_0, text: words[i] };
            lines.push(line);
        }
    }
    return lines;
}

function measure_width(text) {
    const context = document.createElement("canvas")
        .getContext("2d");
    context.font = font;
    return context.measureText(text)
        .width;
}

function text_radius(lines) {
    let radius = 0;
    for (let i = 0, n = lines.length; i < n; ++i) {
        const dy = (Math.abs(i - n / 2) + 0.5) * line_height;
        const dx = lines[i].width / 2;
        radius = Math.max(radius, Math.sqrt(dx ** 2 + dy ** 2));
    }
    return radius * 1.1;
}

function format_node(node) {
    return node.append("svg")
        .attr("overflow", "visible")
        .attr("fill", d =>
            node_color[Object.keys(node_color)
                .filter(c => d[c])[0]])
        .attr("stroke-width", d =>
            node_stroke[Object.keys(node_stroke)
                .filter(c => d[c])[0]]);
}

function format_link(link) {
    return link.append("path")
        .attr("marker-end", d => `url(#marker-${d.rel})`)
        .attr("stroke", d => link_color[d.rel])
        .attr("class", d => d.rel);
}

// Fill modal with content from link href
$("#deps-modal")
    .on("show.bs.modal", function (e) {
        const link = $(e.relatedTarget)
            .data("href");
        const target = $(this)
            .find(".modal-body");
        if (link && target) {
            d3.json(link)
                .then((data) => {
                    // console.log(data);
                    target.html("<svg></svg>");

                    const width = target.width();
                    const height = target.height();

                    const zoom = d3.zoom()
                        .scaleExtent([1 / 4, 4])
                        .on("zoom", zoomed);

                    const svg = d3.select(".modal-body svg")
                        .style("font", font)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "central")
                        .attr("viewBox",
                            `${-width/2} ${-height/2} ${width} ${height}`
                        )
                        .call(zoom);

                    svg.append("defs")
                        .selectAll("marker")
                        .data(new Set(data.links.map(d => d.rel)))
                        .join("marker")
                        .attr("id", d => `marker-${d}`)
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 9)
                        .attr("markerWidth", 5)
                        .attr("markerHeight", 5)
                        .attr("orient", "auto")
                        .attr("fill", d => link_color[d])
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5");

                    const link = svg.append("g")
                        .attr("fill", "none")
                        .attr("stroke-width", 4)
                        .selectAll("path")
                        .data(data.links)
                        .join(format_link);

                    const node = svg.append("svg")
                        .attr("overflow", "visible")
                        .selectAll("svg")
                        .data(data.nodes)
                        .join(format_node);

                    var max_r = 0;
                    node.append("text")
                        .attr("fill", "black")
                        .each(d => {
                            d.lines = lines(d.id);
                            d.r = text_radius(d.lines);
                            max_r = Math.max(d.r, max_r);
                        })
                        .selectAll("tspan")
                        .data(d => d.lines)
                        .enter()
                        .append("tspan")
                        .attr("x", 0)
                        .attr("y", (d, i, x) => ((i - x.length / 2) +
                            0.5) * line_height)
                        .text(d => d.text);

                    node.insert("circle")
                        .attr("r", d => d.r)
                        .attr("stroke", "black")
                        .lower();

                    function ticked() {
                        // link.attr("d", function (d) {
                        //     const dx = d.target.x - d.source.x;
                        //     const dy = d.target.y - d.source.y;

                        //     const path_len = Math.sqrt((dx * dx) +
                        //         (dy * dy));

                        //     const offx = (dx * d.target.r) /
                        //         path_len;
                        //     const offy = (dy * d.target.r) /
                        //         path_len;
                        //     return `
                        //         M${d.source.x},${d.source.y}
                        //         L${d.target.x - offx},${d.target.y - offy}
                        //     `;
                        // });

                        link.attr("d", d => {
                            const r = Math.hypot(d.target.x - d
                                .source.x, d
                                .target.y - d.source.y);
                            return `
                                M${d.source.x},${d.source.y}
                                A${r},${r} 0 0,1 ${d.target.x},${d.target.y}
                            `;
                        });
                        link.attr("d", function (d) {
                            const pl = this.getTotalLength();
                            const r = (d.target.r);
                            const m = this.getPointAtLength(pl -
                                r);
                            const dx = m.x - d.source.x;
                            const dy = m.y - d.source.y;
                            const dr = Math.sqrt(dx * dx + dy *
                                dy);
                            return `
                                M${d.source.x},${d.source.y}
                                A${dr},${dr} 0 0,1 ${m.x},${m.y}
                            `;
                        });

                        node
                            .attr("x", d => d.x)
                            .attr("y", d => d.y);

                        // auto pan and zoom during simulation
                        var bbox = svg.node()
                            .getBBox();
                        const kx = width / bbox.width;
                        const ky = height / bbox.height;
                        const k = Math.min(kx, ky);
                        const tx = -bbox.width / 2 - bbox.x;
                        const ty = -bbox.height / 2 - bbox.y;
                        zoom.translateBy(svg, tx, ty);
                        zoom.scaleBy(svg, k);

                    }

                    function zoomed({ transform }) {
                        link.attr("transform", transform);
                        node.attr("transform", transform);
                    }

                    const simulation = d3
                        .forceSimulation()
                        .nodes(data.nodes)
                        .force("link", d3.forceLink(data.links)
                            .id(d => d.id)
                            .distance(0)
                            // .strength(1)
                        )
                        .force("charge", d3.forceManyBody()
                            .strength(-5 * max_r))
                        .force('collision', d3.forceCollide(1.25 *
                            max_r))
                        .force("x", d3.forceX())
                        .force("y", d3.forceY())
                        .on("tick", ticked);
                });
        }
    });

</script>
{% endblock %}